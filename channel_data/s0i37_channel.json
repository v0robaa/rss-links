{
  "channel": "s0i37_channel",
  "last_update": "2025-11-14T18:36:26.513215+00:00",
  "messages_count": 33,
  "messages": [
    {
      "id": "262",
      "title": "Обнаруживаем \"сырые\" пакеты в радиоэфире.",
      "text": "Обнаруживаем \"сырые\" пакеты в радиоэфире.\nРанее я писал (https://t.me/s0i37_channel/134) как одним простым скриптом можно детектить все Wi-Fi атаки семействах Roque AP. Но есть один универсальный трюк, которым можно выявить всё семейство атак уже на точку доступа, выполняемых с позиции клиента. В сумме оба приёма позволяют покрыть детект практически 100% хакерских Wi-Fi инструментов.\nКогда хакер делает AP-side атаки: деаутентификации и захвата handshake, сбора PMKID или атаки на WPS, то запуск таких утилит как hcxdumptool, bettercap, reaver и некоторых других может быть обнаружен даже не по специфике самой атаки, а по тому, как они генерируют пакеты. Дело в том, что большинство атак на точки доступа требуют создания особых пакетов, которые невозможно отправить силами непосредственно самого чипа Wi-Fi. Поэтому такие утилиты отправляют эти пакеты, создавая их с нуля, через «сырые» сокеты, тогда как легитимные пакеты генерируются напрямую чипом Wi-Fi. Как правило, это создает заметную разницу во времени. Ведь «сырому» пакету нужно пройти куда больший путь: user space → kernel → чип Wi-Fi.\nВсякое подключение к точке доступа — это всегда четкая последовательность этапов аутентификации, ассоциации и так далее. И достигается это соответствующими парами запроса-ответа: auth_req/auth_resp, assoc_req/assoc_resp, ident_req/ident_resp, m1/m2. У легитимных клиентов разница во времени между переходами по этапам request/response составляет несколько миллисекунд, тогда как хакерские инструменты, как правило, имеют задержку в десятки миллисекунд, а иногда и больше.\nДля детектирования таких небольших временных задержек я сделал специальный скрипт (https://github.com/s0i37/defence/blob/main/wifi/timing.py). На скриншоте видно реагирование на появление сырых пакетов от утилиты bettercap.\nНиже приведено сравнительное время реакции различных Wi-Fi клиентов (легитимных и нет) на пакеты от точек доступа:\nТип клиента Разница auth_res - assoc_req\n---------------------                      -------------------------------------------------\nWindows                                 +0.0055 секунд\nMac OS                                   +0.0023 секунд\nwpa_supplicant (Linux)        +0.0042 секунд\nwpa_supplicant (Android)    +0.0026 секунд\nhcxdumptool                          +0.0506 секунд\nbettercap                                +0.0109 секунд\nreaver                                      +0.0101 секунд\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/262",
      "pub_date": "2025-11-12T09:25:30+00:00"
    },
    {
      "id": "261",
      "title": "И вот что случится у хакера (скрин).",
      "text": "И вот что случится у хакера (скрин).\nНесмотря на то, что атака GTC Downgrade часто приводит к отправке\nучетных данных открытым текстом, мы не отправляем их хакеру в открытом\nвиде. А нарочно отправляем в виде хеша, заставляя тем самым его еще и\nбрутить их. Учитывая кажущиеся хакеру высокие шансы на успех,\nон будет просто вынужден это делать.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/261",
      "pub_date": "2025-11-07T08:34:25+00:00"
    },
    {
      "id": "260",
      "title": "Атака GTC downgrade одна из наиболее опасных для компаний Wi-Fi атак. Хакер в случае успеха имеет шансы на получение доменной учетки прямо с улицы, и не редко в виде пароля открытым текстом.",
      "text": "Атака GTC downgrade одна из наиболее опасных для компаний Wi-Fi атак. Хакер в случае успеха имеет шансы на получение доменной учетки прямо с улицы, и не редко в виде пароля открытым текстом.\nВ своём посте (https://t.me/s0i37_channel/208) я писал, как можно замечать такие хакерские точки доступа. Но как противодействовать такой атаке?\nА противодействовать можно всё тем же способом и с помощью следующего незамысловатого кода мы можем закидать хакера фейковыми доменными учетками:\n#!/bin/bash\niface=\"$1\"\nbssid=\"$2\"\nCOUNT=20\nfunction connect(){\nMAX_TIME=5\nbssid=\"$1\"\nuser=\"$2\"\npass=\"$3\"\ncat <<E > /tmp/wpa_eap.conf\nnetwork={\nbssid=$bssid\nkey_mgmt=WPA-EAP\neap=PEAP\nidentity=\"$user\"\npassword=\"$pass\"\nphase1=\"peaplabel=0\"\nphase2=\"auth=MSCHAPV2\"\n}\nE\nsudo timeout $MAX_TIME wpa_supplicant -i \"$iface\" -c /tmp/wpa_eap.conf | while read line; do\nif echo \"$line\" | grep -q 'authentication failed'; then\nbreak\nfi\ndone\n}\nfor _ in `seq $COUNT`; do\nuser=$(shuf -n 1 /opt/wordlists/surnames-translit.txt)\npass=$(pwgen 10 1)\necho \"[*] send $user:$pass\"\nconnect \"$bssid\" \"$user\" \"$pass\"\ndone\nК сожалению на уровне сырых пакетов scapy я пока это не реализовал (сложно), но на bash этот defence-приём выглядит нагляднее.\nСоединяя этот prevent (https://github.com/s0i37/defence/blob/main/wifi/prevent/gtc.sh) с detect (https://github.com/s0i37/defence/blob/main/wifi/eap.py) получаем средство автоматического реагирования на атаку с помощью Eaphammer (скрин).\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/260",
      "pub_date": "2025-11-07T08:34:16+00:00"
    },
    {
      "id": "259",
      "title": "В этом примере, вместо отправки в радиоэфир хэшей от брутабельных паролей, мы отправили хакеру",
      "text": "В этом примере, вместо отправки в радиоэфир хэшей от брутабельных паролей, мы отправили хакеру\nнесколько десятков неподбираемых PMKID.\nЧто же, пожелаем хакеру удачи в этом бесперспективном деле!\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/259",
      "pub_date": "2025-11-01T07:23:28+00:00"
    },
    {
      "id": "258",
      "title": "Реакция хакерского софта будет предсказуема. Bettercap, hcxdumptool, airodump-ng все начинают фиксировать фейковые PMKID хэши, идущие от атакуемой точки доступа и ни как не отличимые от настоящих...",
      "text": "Реакция хакерского софта будет предсказуема. Bettercap, hcxdumptool, airodump-ng все начинают фиксировать фейковые PMKID хэши, идущие от атакуемой точки доступа и ни как не отличимые от настоящих (скрин).\nДостигнув такого успеха и насобирав столько хэшей да ещё и с каждой точки доступа хакер поспешит покинуть \"место преступления\" и приступить к брутфорсу PMKID...\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/258",
      "pub_date": "2025-11-01T07:23:20+00:00"
    },
    {
      "id": "257",
      "title": "Считается, что сбор PMKID с беспроводных сетей WPA PSK это бесшумная атака. Однако ранее я показывал (https://t.me/s0i37_channel/191), что эта атака все же может быть замечена по особенностям...",
      "text": "Считается, что сбор PMKID с беспроводных сетей WPA PSK это бесшумная атака. Однако ранее я показывал (https://t.me/s0i37_channel/191), что эта атака все же может быть замечена по особенностям трафика. Более того можно не только детектить сбор PMKID, но и мешать её проведению. Для этого в момент обнаружения атаки мы можем отправлять фейковые PMKID-хэши в радиоэфир. И для реакции хакерского софта в радиоэфир нужно отправить пакеты beacon и EAPOL M1. А сгенерировать PMKID в M1 от произвольного пароля можно так:\nimport hmac,hashlib\nimport random,string\ndef get_password_unbrutable(len):\nreturn \"\".join(map(lambda _:random.choice(string.printable[:95]),\nrange(len)))\ndef calculate_pmkid(password, ap, essid, sta):\npmk = hashlib.pbkdf2_hmac(\"sha1\", password.encode(\"utf-8\"),\nessid.encode(), 4096, 32)\npmkid = hmac.new(pmk, b\"PMK Name\" + b(ap) + b(sta), hashlib.\nsha1).digest()[:16]\nreturn pmkid\npassword = get_password_unbrutable(8)\neapol_m1_data[95:117] = b\"\\xdd\\x14\\x00\\x0f\\xac\\x04\" + calculate_\npmkid(password, ap, essid, sta)\nПолный код доступен в (https://github.com/s0i37/defence/blob/main/wifi/prevent/m1.py). Теперь соединяя это с детектом (https://github.com/s0i37/defence/blob/main/wifi/pmkid.py) получаем средство автоматического реагироаания на атаку (скриншот).\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/257",
      "pub_date": "2025-11-01T07:23:09+00:00"
    },
    {
      "id": "256",
      "title": "Но если же хакер извлечёт все захваченные handshake, то он сбрутит все теже самые пароли что мы отправляли в радиоэфир (скрин).",
      "text": "Но если же хакер извлечёт все захваченные handshake, то он сбрутит все теже самые пароли что мы отправляли в радиоэфир (скрин).\nНам ни чего не мешает отправить сотни, тысячи таких handshake. Каждый из подобранных паролей это трата времени хакера на проверку актуальности.\nОтправка заведомо брутабельного handshake лишь одна из тактик. Которая может найти применение если защищаемая wifi сеть имеет слабый пароль. Так мы хотя-бы имеем шанс затерять реальный подобранный handshake среди сотен фейковых.\nДругой же тактикой может быть отправка не брутабельных handshake. Ведь каждый такой хэш поставленный на брутфорс снижает общую производительность, снижая тем самым и шансы на успешность взлома легитимного handshake.\nНаконец отправка любого (брутабельного или нет) фейкового handshake в туже секунду что и отправка deauth пакетов не даст хакеру понимания был ли захвачен легитимный handshake или нет.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/256",
      "pub_date": "2025-10-17T09:34:21+00:00"
    },
    {
      "id": "255",
      "title": "Вполне закономерно, что хакер начнёт захватывать огромное количество handshake. На скрине можно видеть что bettercap захватывает их от того самого клиента которого он деаутентицировал. С виду и не...",
      "text": "Вполне закономерно, что хакер начнёт захватывать огромное количество handshake. На скрине можно видеть что bettercap захватывает их от того самого клиента которого он деаутентицировал. С виду и не скажешь что это фейковые handshake. Аналогичное поведение будет и у других инструментов: hcxdumptool, airodump-ng.\nДальше начинается самое интересное. Подготовку к брутфорсу хакер может проводить разными способами. Так если хакер выберет aicrack-ng, то увидит последний принятый handshake, а если hcxpcapngtool, то по дефолту он извлекает первый. Следовательно в каждом случае мы можем просто перезаписать легитимный handshake, защитив тем самым точку доступа и послать хакера брутить левый хэш.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/255",
      "pub_date": "2025-10-17T09:34:08+00:00"
    },
    {
      "id": "254",
      "title": "Сегодня существует большое слепое пятно безопасности - беспроводные сети. Ещё один периметр, который есть почти у каждой компании и который практически никогда ни чем не охраняется. В итоге все мы...",
      "text": "Сегодня существует большое слепое пятно безопасности - беспроводные сети. Ещё один периметр, который есть почти у каждой компании и который практически никогда ни чем не охраняется. В итоге все мы привыкли к тому что все атаки на этом поле невидимы и хакеру все сходит с рук.\nВ своих постах, а так же в статье (https://xakep.ru/2025/01/10/wireless-self-defence/) я показал, что это может быть не так, и продемонстрировал как детектить все актуальные атаки на wifi.\nНо сейчас я хотел бы поделиться тем, как можно активно мешать хакеру.\nИ это будет маленький цикл постов про предотвращение/смягчение атак на wifi.\nЧто бы помешать хакеру провести захват WPA handshake через деаутентификацию, в момент детекта атаки мы можем начать отправлять в радиоэфир фейковые хэши. И что бы хакерский софт среагировал, достаточно отправить пакеты: beacon, EAPOL m1 и m2. А собрать произвольный handshake мы можем примерно так:\nimport hmac,hashlib\nimport random\ndef PRF_512(key,A,B):\nreturn b''.join(hmac.new(key,A+chr(0).encode()+B+chr(i).encode(),hashlib.sha1).digest() for i in range(4))[:64]\ndef get_rand(n):\no = b''\nfor _ in range(n):\no += int(random.random()*255).to_bytes(1, 'big')\nreturn o\npmk = hashlib.pbkdf2_hmac('sha1', password.encode(), essid.encode(), 4096, 32)\nsnonce = get_rand(32)\nptk = PRF_512(pmk, b\"Pairwise key expansion\", min(b(ap),b(sta))+max(b(ap),b(sta))+min(anonce,snonce)+max(anonce,snonce))\nkck = ptk[0:16]\nmic = hmac.new(kck, b\"\\x01\\x03\\x00\\x75\" + bytes(eapol_data_4[:77]) + bytes.fromhex(\"00000000000000000000000000000000\") + bytes(eapol_data_4[93:]), hashlib.sha1).digest()[0:16]\neapol_data_4[77:77+16] = mic\nДобавив вызов этого prevent-скрипта (https://github.com/s0i37/defence/blob/main/wifi/prevent/m2.py) в detect-скрипт (https://github.com/s0i37/defence/blob/main/wifi/deauth.py) мы получаем готовое решение для автоматического реагирования на атаку деаутентификации (скрин).\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/254",
      "pub_date": "2025-10-17T09:33:55+00:00"
    },
    {
      "id": "253",
      "title": "Когда хакер атакует какой либо сервис, например брутит пароли, то обычно на такое реагируют блокированием его IP:",
      "text": "Когда хакер атакует какой либо сервис, например брутит пароли, то обычно на такое реагируют блокированием его IP:\niptables -A INPUT -s $attacker -j DROP\nНо целеустремленного хакера этим врядли остановишь. Так почему бы не дать ему того что он хочет - пусть атакует, только немного не того кого ожидает...\nВсего двумя правилами на фаерволе мы можем повернуть вредоносный трафик вспять и направить атаку на сам источник:\niptables -t nat -I PREROUTING -s $hacker -p tcp --dport 22 -j DNAT --to-destination $hacker:22\nsysctl -w net.ipv4.ip_forward=1\niptables -t nat -I POSTROUTING -p tcp --dport 22 -d $hacker -j MASQUERADE\nВ отличие от блокировки порта такой трюк практически незаметен для хакера, ведь целевой порт как был открыт так и остался (изменится только баннер и удвоится IP.ttl). Но после ввода этих команд хакер будет подбирать пароли уже сам у себя (скрин), думая что атакует ваш сервер. И в случае если подберёт пароль установит себе криптомайнер, или что там они устанавливают.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/253",
      "pub_date": "2025-10-10T09:38:40+00:00"
    },
    {
      "id": "252",
      "title": "Не редки случаи, когда хакеры натравливают на свои цели тяжёлую артиллерию – коммерческие (обычно крякнутые) сканеры, такие как, например, Acunetix.",
      "text": "Не редки случаи, когда хакеры натравливают на свои цели тяжёлую артиллерию – коммерческие (обычно крякнутые) сканеры, такие как, например, Acunetix.\nВсего через минуту, как хакер натравил на нас сканер уязвимостей, вся его оперативная память оказалась исчерпана, и вся ОС зависла на несколько минут. Разумеется, никаких результатов у такого сканирования не будет.\nВелика вероятность, что если хакер попадёт в наш «ZIP-капкан», он ощутит и более негативные последствия…\nВ ОС Linux существует известная проблема механизма OOM Killer, при которой утечка памяти приводит к сильному замедлению системы вплоть до зависания ОС. И подвержены ей главным образом браузеры.\nТак что, если хакер попробует открыть наш сайт в браузере, то его ОС после утечки всей памяти и вовсе намертво зависнет, до полной перезагрузки системы.\nПовесив систему хакеру и, вероятно, вынудив его сделать жесткую перезагрузку, мы можем заставить его потерять какие-то несохранённые файлы.\nКак же можно применить это для защиты функционирующего сайта? Одним из простых решений может быть проксирование на ZIP-бомбу через nginx какой-нибудь не используемый каталог сайта, но такой, который точно будут искать хакеры. Отличными выбором могут быть каталоги .git или .svn. Они вряд ли нужны вашему веб-приложению, но для любого хакера must-have заглянуть туда.\nserver {\n...\nlocation /.git {\nproxy_pass http://localhost:8080;\n}\n}\nЛегитимные пользователи такие каталоги вряд ли станут искать, а тот, кто станет – будет проучен!\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/252",
      "pub_date": "2025-10-06T08:20:21+00:00"
    },
    {
      "id": "251",
      "title": "Давайте теперь посмотрим, как справятся с нами разнообразные хакерские разведывательные сканеры, ведь именно они наша главная цель.",
      "text": "Давайте теперь посмотрим, как справятся с нами разнообразные хакерские разведывательные сканеры, ведь именно они наша главная цель.\nКак правило, обнаружив сайт, хакеры запускают инструменты, простукивающие его рабочий каталог на наличие потенциально интересных ресурсов. Например, хакер может сделать это популярным инструментом dirsearch.\nОбычно такие инструменты закидывают сайт десятками тысяч запросов, но тут на первом же запросе ещё на этапе калибровки dirsearch исчерпал всю память и аварийно завершился. И произошло это через каких-то 3-4 секунды.\nДругие аналоги: wfuzz, ffuf ведут себя аналогичным образом - падают наступив на ZIP-мину.\nПадение даже одного хакерского процесса с полным исчерпанием ресурсов ОС негативно сказывается и на общей производительности системы - тк память всех соседних процессов вытесняется на диск (swap), а сам дисковый кэш, обеспечивающий быстрый ввод-вывод, будет сброшен.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/251",
      "pub_date": "2025-10-06T08:20:12+00:00"
    },
    {
      "id": "250",
      "title": "Сегодня веб формирует большую часть поверхности атак современного периметра.  И есть один весьма болезненный приём против хакеров, ковыряющих чужой веб...",
      "text": "Сегодня веб формирует большую часть поверхности атак современного периметра.  И есть один весьма болезненный приём против хакеров, ковыряющих чужой веб...\nПротокол HTTP для экономии трафика позволяет доставлять содержимое со сжатием. Но насколько сильного сжатия можно достичь, если использовать лишь одну единственную последовательность – например, всего один байт?\nТрадиционно ZIP-бомбы являлись оружием хакеров, но\nPatientZero предложил интересную идею их использования в агрессивно защитных целях - ZIP-мины.\nТак всего один 1МБ данных, принятых по протоколу HTTP, может развернуться у хакера в 1ГБ в его оперативной памяти. 10МБ, соответственно, превратится уже в 10ГБ, что почти наверняка положит процесс на типовом арендованном сервере. Ну а 30МБ думаю хватит с головой и на средний десктоп.\nСегодня открытие обычного сайта в браузере – это скачивания порядка 10МБ данных, что с нынешними скоростями происходит за пару секунд. Значит 10ГБ оперативной памяти мы заберем у атакующего быстрее, чем он успеет подумать.\nТакая встречная атака настолько проста в реализации, что провернуть её можно даже в терминале всего несколькими командами (скрин). Теперь открытие любой веб-страницы на таком листенере вызовет взрыв ZIP-бомбы в RAM, которая заберёт всю память в радиусе 10ГБ.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/250",
      "pub_date": "2025-10-06T08:20:01+00:00"
    },
    {
      "id": "249",
      "title": "Другим вариантом испортить сканирование является его экстремальнное замедление. Мы можем отправлять по одному байту раз в секунду и делать так бесконечно. И вот сколько часов уходит на анализ только...",
      "text": "Другим вариантом испортить сканирование является его экстремальнное замедление. Мы можем отправлять по одному байту раз в секунду и делать так бесконечно. И вот сколько часов уходит на анализ только одного открытого порта (скрин).\nСкрипт https://github.com/s0i37/defence/blob/main/garbage.py из моей defence-коллекции умеет делать и то и другое.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/249",
      "pub_date": "2025-09-29T09:20:48+00:00"
    },
    {
      "id": "248",
      "title": "Как ещё мы можем навставлять палки в колеса хакерам, сканирующим наши ресурсы?",
      "text": "Как ещё мы можем навставлять палки в колеса хакерам, сканирующим наши ресурсы?\nМожно начать отправлять бесконечный трафик с каждого всевдо-открытого порта, например nc -nv -lp 8888 < /dev/urandom.\nИ вот как реагирует на это nmap атакующего (скрин). Несколько гигов оперативки на один порт.\nОднако nmap не одинаково реагирует на разные байты, так было установлено что байты 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x08, 0x0a, 0x0b, 0x0e, 0x0f, 0x10, 0x11 вызывают более сильное исчерпание ресурсов. Вплоть до полного потребления RAM и SWAP и аварийного завершения (скрин).\nЕсли мы имеем дело не с хакером, а с ботами, то их автоматизированный конвейер вполне может рухнуть от банальной утечки памяти.\nПравда такое потребует от нас лить немало трафика, что иногда является расточительством.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/248",
      "pub_date": "2025-09-29T09:20:40+00:00"
    },
    {
      "id": "247",
      "title": "Возможно кто то из вас скажет \"так есть же portspoof\". Действительно, но есть у него один маленький изъян - он уж слишком рандомный и каждый раз на одном и том же порту иммитирует новый сервис, что...",
      "text": "Возможно кто то из вас скажет \"так есть же portspoof\". Действительно, но есть у него один маленький изъян - он уж слишком рандомный и каждый раз на одном и том же порту иммитирует новый сервис, что уже не правдоподобно и может быть вычислено.\nИ вот как кстати можно обойти portspoof: достаточно два раза сделать nmap -sV, где баннеры не совпали там подделка, где совпали - истинный сервис.\nРазумеется такой недочёт исправлен в моем скрипте.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/247",
      "pub_date": "2025-09-26T09:31:45+00:00"
    },
    {
      "id": "246",
      "title": "Надоело что ваш периметр постоянно сканируют nmap? Как на счет сделать все порты открытыми? Сделать это можно буквально в пару команд:",
      "text": "Надоело что ваш периметр постоянно сканируют nmap? Как на счет сделать все порты открытыми? Сделать это можно буквально в пару команд:\niptables -t nat -A PREROUTING -i eth0 -p tcp --dport 22 -j REDIRECT --to-ports 22\niptables -t nat -A PREROUTING -i eth0 -p tcp -m conntrack --ctstate NEW -j REDIRECT --to-ports 1234\nwhile sleep 1; do nc -nv -lp 1234; done\nА коммерческие фаерволы умеют это из коробки.\nНо я предлагаю пойти дальше - иммитировать случайный сервис на каждом псевдо-открытом порту. Мой ещё один скрипт из defence-коллекции (https://github.com/s0i37/defence/blob/main/services.py) прекрасно справляется с этим. Он использует туже самую базу фингерпринтов nmap для иммитации сервиса (nmap-service-probes), но на этот раз использует ответы.\nИ как теперь среди этого найти настоящие сервисы?\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/246",
      "pub_date": "2025-09-26T09:31:34+00:00"
    },
    {
      "id": "245",
      "title": "Почему когда мы сканируем порты то часто получаем результат в ту же секунду, а иногда ждём десятки минут? Всё дело в TCP-RST пакетах...",
      "text": "Почему когда мы сканируем порты то часто получаем результат в ту же секунду, а иногда ждём десятки минут? Всё дело в TCP-RST пакетах...\nСамый простой способ помешать хакеру проводить сканирование портов реализуется буквально в одну простую команду:\niptables -A OUTPUT -o eth0 -p tcp --tcp-flags RST RST -j DROP\nВсего одно правило на фаерволе в десятки тысяч раз замедляет сканирование портов вашего сервера.\nЭто правило запрещает вашей системе отправлять RST-пакет на каждый закрытый порт если его сканируют. Что в свою очередь вынуждает атакующего каждый раз выжидать определенное время для принятия решения о статусе порта.\nИ это будет маленький цикл статей про грабли и приколы против хакеров.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/245",
      "pub_date": "2025-09-22T10:01:37+00:00"
    },
    {
      "id": "244",
      "title": "3. Понять что те или иные разные IP-адреса это фактически один и тот же компьютер.",
      "text": "3. Понять что те или иные разные IP-адреса это фактически один и тот же компьютер.\nНаконец, помониторив трафик более продолжительное время мы можем заметить, что uptime одной из машин за VPN-сервером внезапно совпал с одной из машин, чей трафик пришёл из провайдерской домашней сети (скрин).\nТолько что мы сделали деанон атакующего, который по неосторожности допустил утечку сетевых пакетов вне VPN. Несмотря на то, что ни какие видимые компрометирующие данные хакер явно не посылал, всего одного пакета хватило, чтобы сопоставить его VPN-активность с домашним IP.\nИ это хороший пример почему proxy более анонимен нежели vpn. Хоть vpn и удобнее для хакера, но он не делает развязки по сетевому стеку, позволяя проводить такой fingerprint.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/244",
      "pub_date": "2025-09-19T12:43:20+00:00"
    },
    {
      "id": "243",
      "title": "2. Увидеть сколько фактических источников трафика находится за IP-адресом.",
      "text": "2. Увидеть сколько фактических источников трафика находится за IP-адресом.\nПомониторив какое то время за трафиком с данного узла можно заметить что пакеты приходят с трёмя разными uptime (скрин).\nИными словами этим VPN пользуется минимум три машины и возможно три человека.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/243",
      "pub_date": "2025-09-19T12:43:12+00:00"
    },
    {
      "id": "242",
      "title": "В протоколе TCP, скрыто одно очень интересное поле — опция timestamp, по которой можно рассчитать время когда была загружена ОС. И что ещё интереснее, эту опцию ОС зачастую указывает сама, даже если...",
      "text": "В протоколе TCP, скрыто одно очень интересное поле — опция timestamp, по которой можно рассчитать время когда была загружена ОС. И что ещё интереснее, эту опцию ОС зачастую указывает сама, даже если её об этом явно не просят. Такая информация встречается не только при исходящих подключениях, но и так же входящих. То есть большинство из тех узлов что посылают на нас трафик и как-то пытаются атаковать, бессознательно разглашают в TCP-пакетах свои uptime.\nНе на всех типах ОС это поле фактически совпадает с временем загрузки, но важно другое — оно постоянно и достаточно уникально для каждого компьютера. А значит оно, подобно уникальному хэшу, способно выделить трафик произвольного ПК из общей массы, вне зависимости от его IP! Для этого я написал скрипт (https://github.com/s0i37/defence/blob/main/uptime.py)\nИ с этой информацией мы можем:\n1. Различать IP-адрес и фактический источник атаки. То есть является ли этот узел реально вредоносным или это лишь шлюз. Для этого нужно сравнить uptime у входящего подключения с uptime который мы запросим у соответствующего IP. В примере на скрине uptime у входящего подключения не совпал с фактическим uptime у узла. Это означает, что данный узел не является фактическим источником атаки, он только шлюз и пересылает через себя чьи-то пакеты. Имя сети указывает на то, что это обычный хостинг. Учитывая что фингерпринты различаются, хакер использует этот сервер в качестве VPN, а не прокси — т. к. сервер пересылает чужие пакеты целиком.\nТакое ещё можно сделать анализом IP.ttl о чём я писал ранее.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/242",
      "pub_date": "2025-09-19T12:42:59+00:00"
    },
    {
      "id": "241",
      "title": "Ещё одна любопытная вещь, которую мы можем узнать об атакующем по его трафику, реализуется через анализ IP.id. Я уже писал ранее об этом поле в пакете (https://t.me/s0i37_channel/43), что оно часто...",
      "text": "Ещё одна любопытная вещь, которую мы можем узнать об атакующем по его трафику, реализуется через анализ IP.id. Я уже писал ранее об этом поле в пакете (https://t.me/s0i37_channel/43), что оно часто является глобально инкрементируемым, а значит что анализируя его изменение мы можем видеть сколько пакетов источник трафика отправляет куда то ещё кроме нас. Иными словами мы можем заключить - является ли атака таргетированной или веерной на множество хостов.\nЕще один скрипт из моей defence-коллекции (https://github.com/s0i37/defence/blob/main/ip_id.py) автоматически делает это. По каждому входящему сетевому пакету мы можем видеть страну, город, имя сети, ОС, а так же количество пакетов генерируемых хостом куда то ещё кроме нас. Как можем видеть на примере первый источник трафика имеет слабый инкремент, свидетельствующий что практически ни куда кроме нашего узла он пакеты не посылает — это говорит о вероятно таргетированной атаке. Второй узел помимо нас успевает отправить от нескольких сотен до тысячи пакетов — это говорит о вероятной веерной атаке сразу на множество узлов.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/241",
      "pub_date": "2025-09-15T07:37:22+00:00"
    },
    {
      "id": "240",
      "title": "Пару лет назад я написал статью кунг-фу enumeration (https://xakep.ru/2022/11/17/enumeration-guide/) где поделился tcp/ip сетевыми трюками, что могут быть применены атакующим для получения разной...",
      "text": "Пару лет назад я написал статью кунг-фу enumeration (https://xakep.ru/2022/11/17/enumeration-guide/) где поделился tcp/ip сетевыми трюками, что могут быть применены атакующим для получения разной неочевидной информации о цели. Но как на счёт обратного? Узнать что то об атакующем, только по его трафику.\nЭто будет небольшая серия постов про \"обратный\" enumeration.\nЯ уже рассказывал, как много может дать нам анализ ip.ttl, но ещё по этому полю пакета мы можем понять где находится реальный источник трафика - на узле с белым ip как выделенный сервер, или где то в глубине локальной сети за NAT, то есть является обычной рабочей станцией. Все что нужно это посчитать разницу ip.ttl у входящего и исходящего подключений. У сервера с белым ip разница будет нулевая, а у узлов за NAT соответственно не нулевая.\nМой скрипт (https://github.com/s0i37/defence/blob/main/nat.py) делает всю эту магию. Для каждого источника входящего трафика он определяет город, страну, имя сети whois, тип ОС, а так же делая встречный ping, вычисляет где расположен хост на DMZ или в локалке, как глубоко, и сколько узлов нас разделяет.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/240",
      "pub_date": "2025-09-10T11:05:40+00:00"
    },
    {
      "id": "239",
      "title": "Заметил как то забавную вещь. В ходе пентеста получаю уведомление от скрипта из предыдущего поста, что таргет заблокировал меня, проверяю - действительно порт стал закрыт, но dirsearch на этот таргет...",
      "text": "Заметил как то забавную вещь. В ходе пентеста получаю уведомление от скрипта из предыдущего поста, что таргет заблокировал меня, проверяю - действительно порт стал закрыт, но dirsearch на этот таргет при этом продолжает работать. Как такое может быть?\nПричина это Keep-alive, что использует соединение многократно. И как становится понятным фаерволы и waf могут ненадежно защищать цель, блокируя новые подключения, но забывая про уже установленные коннекты (скрин).\nИ вот как можно попробовать сделать bypass таких waf:\nsocat -v tcp-listen:1234,fork,reuseaddr - < /tmp/fifo | socat -v - tcp-connect:1.2.3.4:80,keepalive,keepidle=10,keepintvl=10,keepcnt=100 > /tmp/fifo\nsocat -v tcp-listen:1234,fork,reuseaddr - < /tmp/fifo | socat -v - openssl:1.2.3.4:443,verify=0 > /tmp/fifo\ndirsearch -u http://127.0.0.1:1234\nЧто бы многократно использовать одно и то же tcp-соединение и разделять его между разными утилитами (dirsearch, gobuster, etc) мы можем создать до блокировки висящее подключение.\nКонечно же такой коннект рано или поздно может закрыть и удаленная сторона, но сам факт того, что мы взаимодействуем с target после активации waf весьма интересен.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/239",
      "pub_date": "2025-08-15T08:20:27+00:00"
    },
    {
      "id": "238",
      "title": "Написал чрезвычайно простой но эффективный скрипт для мониторинга доступности целей во время пентеста.",
      "text": "Написал чрезвычайно простой но эффективный скрипт для мониторинга доступности целей во время пентеста.\n#!/bin/bash\nsites=\"$1\" # ip port schema vhost\n[ -z \"$AGENT\" ] && AGENT='Mozilla/5.0'\nDOWNLOAD_TIME=10\nINTERVAL=5\nshopt -s lastpipe\nwhile sleep $INTERVAL; do\ndate\ncat \"$sites\" | while read ip port schema vhost; do\ncode=$(curl -s --insecure --http1.1 --max-time $DOWNLOAD_TIME -A \"$AGENT\" -X 'GET' --connect-to \"$vhost::$ip\" -H \"Host: $vhost\" \"$schema://$vhost:$port/\" -w '%{http_code}' -o /dev/null 2> /dev/null)\nwords=$(curl -s --insecure --http1.1 --max-time $DOWNLOAD_TIME -A \"$AGENT\" -X 'GET' --connect-to \"$vhost::$ip\" \"$schema://$vhost:$port/\" 2> /dev/null | wc -w)\nif ! grep -q \"$ip $port $vhost:\" /tmp/http_mon.log 2> /dev/null; then # init\necho \"[*] $ip $port $vhost: $code $words\"\necho \"$ip $port $vhost: $code $words\" >> /tmp/http_mon.log\nelif ! grep -q \"$ip $port $vhost: $code $words\" /tmp/http_mon.log; then # ban\necho \"[-] $(grep \"$ip $port $vhost:\" /tmp/http_mon.log)\"\necho \"[+] $ip $port $vhost: $code $words\"\nmplayer siren.mp3\npkill --signal STOP -f \"$ip|$vhost\"\nelse # ok\npkill --signal CONT -f \"$ip|$vhost\"\nfi\ndone\ndone\nВ чем суть. Когда мы делаем активную разведку (gobuster vhost, dirsearch, arjun), что является весьма инвазивной активностью, часть таргетов может отлетать из за waf или firewall. И если мы применяем автоматизацию в виде всем известных пайплайнов, то приличная часть запросов не достигнет целей, а мы возможно даже не заметим этого. Но только не теперь.\nСкрипт постоянно мониторит таргеты и даёт понять, что какая то цель заблокировала нас - когда меняется fingerprint сайта (код+длина). Так же скрипт умеет сам ставить на паузу все запущенные процессы, что атакуют данный таргет и возобновляет их если блокировка снята.",
      "link": "https://t.me/s0i37_channel/238",
      "pub_date": "2025-08-12T10:51:58+00:00"
    },
    {
      "id": "237",
      "title": "Миновал 3й ежегодный Pentest Awards, на котором мне довелось занять 2е место в номинации out of scope с работой \"Google в локалке\".",
      "text": "Миновал 3й ежегодный Pentest Awards, на котором мне довелось занять 2е место в номинации out of scope с работой \"Google в локалке\".\nСпасибо жюри, что оценили работу!\nТак же поздравляю моих коллег из УЦСБ, с победой @VlaDriev, @Oki4_Doki (канал @GigaHack), @Levatein (1C hacker) , @N4m3U53r, @Alevuc (автор последней обложки xaker.ru) в этой и других номинациях. Практически каждый из наших пентестеров занял призовое место!\nПару слов о моём кейсе. В этом году решил не подаваться во взломы, а попробовать в разработке.\nМоя номинированная разработка (Google за 200 строк кода на bash) фактически была реализована еще 9 лет назад, но так вышло, что только недавно я решил о ней написать достаточно подробно и заслать в подходящую номинацию. Тогда в 2016, я и подумать не мог что это принесёт мне победу в таком далёком будущем. Все потому что проблема чувствительных данных актуальна будет всегда.\nВ последующие годы между (и в ходе) пентестов я сделал ещё множество разработок от небольших утилит до целых систем. Что то из этого я не смогу опубликовать в ближайшее время т.к. это либо для внутреннего использования либо для личных исследований. Но частью своих разработок я еще ни раз поделюсь!\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/237",
      "pub_date": "2025-08-04T09:40:30+00:00"
    },
    {
      "id": "236",
      "title": "Обычно не делаю рекламы в своём канале, но для жены сделал исключение (ИБ у нас семейное ремесло). Знаю, что меня читают не только пентестеры, но и другие специалисты ИБ.",
      "text": "Обычно не делаю рекламы в своём канале, но для жены сделал исключение (ИБ у нас семейное ремесло). Знаю, что меня читают не только пентестеры, но и другие специалисты ИБ.\nХочу порекомендовать канал своей жены, которая занимается Комплаенсом более 10 лет. Экспертный канал о требованиях ИБ в области персональных данных и критической информационной инфраструктуры\nhttps://t.me/itiscompliance",
      "link": "https://t.me/s0i37_channel/236",
      "pub_date": "2025-08-01T07:33:43+00:00"
    },
    {
      "id": "235",
      "title": "Маленькие хакерские секреты простых вещей. Как на пентесте быстро и просто увидеть что цель это ханипот. И при этом даже не спускаясь с сетевого уровня до уровня приложения.",
      "text": "Маленькие хакерские секреты простых вещей. Как на пентесте быстро и просто увидеть что цель это ханипот. И при этом даже не спускаясь с сетевого уровня до уровня приложения.\nВсе дело в том что, многие производители ханипотов часто забывают эмулировать стэк ОС для соответствующих специфичных сервисов.\nВидим типичный набор портов Windows, а сетевой стэк Linux.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/235",
      "pub_date": "2025-07-31T09:00:45+00:00"
    },
    {
      "id": "234",
      "title": "Wi-Fi pivoting.",
      "text": "Wi-Fi pivoting.\nКогда физический периметр пробит через WiFi нужно развивать атаки в локалке. Физическое расположение может накладывать на нас ограничения по возможностям и удобству, не позволяя проводить работы в том или ином месте. И тут мы можем использовать одноплатник с 4g модемом, оставленный в точке приёма или Android смартфон в кармане у коллеги, что будет стоять в нужной точке. Оба варианта после подключения к целевой беспроводной сети настраиваются в режим 4g->wifi шлюза (ip_forward + masquerade), давая комфортный удаленный доступ в сеть с любого места через данные устройства. С этим всё достаточно просто и этот приём я хорошо описывал в статье на ][ и в своей книге.\nЕсли все машины в целевой wifi сети пропатчены или закрыты фаерволом в ход можно пустить MiTM атаки (перехват трафика) и responder. Но что бы проводить такие атаки нужно быть непосредственно подключенным к wifi либо организовать L2-туннель в целевую сеть.\nКак правило такое достигается через сетевой мост. Но к сожалению в Linux сбриджить wlan0 и vpn можно только в режиме точки доступа (AP), тогда как мы находимся в режиме клиента (STA), будучи подключенными к целевой сети.\nВстроенная в Linux утилита tc, способная зеркалировать интерфейсы, так же не справляется с этой задачей (по крайней мере мне не удалось).\nИ тут я вспомнил про одну древнюю и простую программку https://github.com/escitalopram/wlan_kabel, которая способна сделать как раз то что нам нужно.\nsudo ssh root@android_or_rpi -o Tunnel=ethernet -w any:any\nwpa_supplicant -i wlan0 -c /tmp/target.conf\n./wlan_kabel \"wlan0\" \"tap1\" \"$mac_of_your_tap\"\nПосле ввода этой команды (на удаленном одноплатнике или android) на локальном ноутбуке tap-интерфейс от ssh будет L2-связан с целевым Wi-Fi, открывая удаленное проведение MiTM и responder-атак.",
      "link": "https://t.me/s0i37_channel/234",
      "pub_date": "2025-07-29T09:01:26+00:00"
    },
    {
      "id": "233",
      "title": "Сейчас мой краулер (https://github.com/s0i37/crawl) парсит следующие форматы: word, excel, презентации, visio, pdf - из всех этих типов умеет извлекать вложенные картинки, так же парсит все типы...",
      "text": "Сейчас мой краулер (https://github.com/s0i37/crawl) парсит следующие форматы: word, excel, презентации, visio, pdf - из всех этих типов умеет извлекать вложенные картинки, так же парсит все типы архивов с бесконечной вложенностью, cab/rpm/deb-пакеты, все исполняемые файлы (pe,elf), распознает текст на картинках (ru,en), в аудио (ru,en), с fps=1 распознает что есть в видео включая звук, извлекает thumbs.db, sqlite, дампы трафика, lnk-файлы, декомпилирует байткод, и логи винды evtx - одним словом всё, чаще всего лежит на шарах. И делает это все за какие то 300 строк кода на bash.\nА теперь благодаря специально собранному мини образу alpine, с ntfs-3g и impacket, запускаему через qemu, краулер из любого образа диска быстро и без скачивания извлечет /root/.bash_history, /home/*/.bash_history, /etc/shadow, историю браузера, а так же хэши sam и security.\n\n[Media: Видео]",
      "link": "https://t.me/s0i37_channel/233",
      "pub_date": "2025-06-27T11:54:44+00:00"
    },
    {
      "id": "232",
      "title": "Но что если мы имеем дело с vhdx, vdi, vmdk образами? И на помощь тут может прийти qemu. Qemu умеет открывать все популярные форматы образов дисков на лету, без предварительной переконвертации. И вот...",
      "text": "Но что если мы имеем дело с vhdx, vdi, vmdk образами? И на помощь тут может прийти qemu. Qemu умеет открывать все популярные форматы образов дисков на лету, без предварительной переконвертации. И вот такой командой мы можем запустить виртуалку задействовав нужный образ диска прямо с шары:\nsudo kvm -hda kali.qcow2 -drive file=/media/share/path/to/server.vhdx,format=vhdx -snapshot\nПосле чего внутри виртуалки мы уже можем подмонтировать диск и приступить к поиску информации в нём, не скачивая при этом сотни гигабайт.\nКак можно заметить на скриншоте для открытия образа в 120ГБ потребовалось скачать лишь 5МБ.\nПолучается какой бы большой файл мы не нашли на SMB, всё может быть доступно без полного скачивания, нужно лишь знать подход.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/232",
      "pub_date": "2025-06-27T11:54:30+00:00"
    },
    {
      "id": "231",
      "title": "В любой локальной сети общедоступные сетевые диски большая проблема для безопасности и об этом я писал статью (https://www.google.com/amp/s/habr.com/ru/amp/publications/878340/) . Но поиск иголки в...",
      "text": "В любой локальной сети общедоступные сетевые диски большая проблема для безопасности и об этом я писал статью (https://www.google.com/amp/s/habr.com/ru/amp/publications/878340/) . Но поиск иголки в стоге сена (файликов с паролями) лишь один из подходов. Как на счёт поиска чего то грандиозного - например бэкапов?\nНайти бэкапы даже где то в глубине сотен сетевых дисков не так уж и сложно - их выдаёт размер. Для этого нам нужно рекурсивно собрать списки файлов, включая их размер. Элегантно сделать это можно маленьким циклом:\nwhile read ip share; do mount.cifs \"//$ip/$share\" /mnt/1 -o ro,user=user,pass=pass\ntimeout 300 find \"/mnt/1\" -printf '%p | %k KB | %t\\n'\nsudo umount /mnt/1\ndone > smb-files.txt\nУтилита find умеет среди прочего фиксировать размер и дату файла.\nДальше что бы найти файлы, скажем за 2025 год и более 1ГБ можно воспользоваться командой:\ncat smb-files.txt | grep ' 2025' | egrep ' [0-9]{6,10} KB'\nИ перед нами появляются бэкапы 1ГБ, 10ГБ, 100ГБ.\nИ теперь возникает главный вопрос - что делать если перед нами лежит огромный файл, а сеть или время не позволяет его полностью скачать? Ответ перед нашими глазами - SMB. SMB предоставляет нам сетевой ввод-вывод, так что мы можем просто смонтировать нужный сетевой диск и открыть файл будто бы он локальный. Это позволит читать файл не целиком, а лишь нужные его части. Например из любого архива мы всегда можем достать только нужный нам файл, а листинг займёт лишь пару мегабайт:\nmount.cifs \"//fs.corp/backup\" /media/share -o ro,user=user,pass=pass\n7z x /media/share/path/to/dc.7z windows/system32/ntds.dit\nВ результате мы можем обработать файл не скачивая его.",
      "link": "https://t.me/s0i37_channel/231",
      "pub_date": "2025-06-27T11:54:18+00:00"
    },
    {
      "id": "230",
      "title": "Пару дней назад сделал коммит в radare2 и теперь вот так он может выглядеть сразу из коробки. Инфраструктура для реверс-инжиниринга Radare2 достаточно сложна для новичка, тк сильно завязана на...",
      "text": "Пару дней назад сделал коммит в radare2 и теперь вот так он может выглядеть сразу из коробки. Инфраструктура для реверс-инжиниринга Radare2 достаточно сложна для новичка, тк сильно завязана на хоткеях и не имеет большого встроенного визуала. Теперь с новыми дефолтными панелями можно комфортно дебажить x86 и x86_64 с декомпиляцией и подсветкой кода, просматривать регистры, переменные, стэк и видеть какие байты читаются/пишутся в памяти. Максимально стилизированно под ollydbg, стандарт в дебагинге.\nИ раз radare2 это в первую очередь SBA, то такой подход можно применять не только в динамике (отладке), но и в статическом анализе, благодаря встроенному эмулятору ESIL.\n\n[Media: Фото]",
      "link": "https://t.me/s0i37_channel/230",
      "pub_date": "2025-06-20T08:39:23+00:00"
    }
  ]
}