<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>s0i37_channel</title><link>https://t.me/s0i37_channel</link><description>none</description><language>ru</language><lastBuildDate>Fri, 07 Nov 2025 08:34:25 +0000</lastBuildDate><item><title>И вот что случится у хакера (скрин).</title><link>https://t.me/s0i37_channel/261</link><description>И вот что случится у хакера (скрин).
Несмотря на то, что атака GTC Downgrade часто приводит к отправке
учетных данных открытым текстом, мы не отправляем их хакеру в открытом
виде. А нарочно отправляем в виде хеша, заставляя тем самым его еще и
брутить их. Учитывая кажущиеся хакеру высокие шансы на успех,
он будет просто вынужден это делать.

[Media: Фото]</description><pubDate>Fri, 07 Nov 2025 08:34:25 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_261</guid></item><item><title>Атака GTC downgrade одна из наиболее опасных для компаний Wi-Fi атак. Хакер в случае успеха имеет шансы на получение доменной учетки прямо с улицы, и не редко в виде пароля открытым текстом.</title><link>https://t.me/s0i37_channel/260</link><description>Атака GTC downgrade одна из наиболее опасных для компаний Wi-Fi атак. Хакер в случае успеха имеет шансы на получение доменной учетки прямо с улицы, и не редко в виде пароля открытым текстом.
В своём посте (https://t.me/s0i37_channel/208) я писал, как можно замечать такие хакерские точки доступа. Но как противодействовать такой атаке?
А противодействовать можно всё тем же способом и с помощью следующего незамысловатого кода мы можем закидать хакера фейковыми доменными учетками:
#!/bin/bash
iface="$1"
bssid="$2"
COUNT=20
function connect(){
MAX_TIME=5
bssid="$1"
user="$2"
pass="$3"
cat &lt;&lt;E &gt; /tmp/wpa_eap.conf
network={
bssid=$bssid
key_mgmt=WPA-EAP
eap=PEAP
identity="$user"
password="$pass"
phase1="peaplabel=0"
phase2="auth=MSCHAPV2"
}
E
sudo timeout $MAX_TIME wpa_supplicant -i "$iface" -c /tmp/wpa_eap.conf | while read line; do
if echo "$line" | grep -q 'authentication failed'; then
break
fi
done
}
for _ in `seq $COUNT`; do
user=$(shuf -n 1 /opt/wordlists/surnames-translit.txt)
pass=$(pwgen 10 1)
echo "[*] send $user:$pass"
connect "$bssid" "$user" "$pass"
done
К сожалению на уровне сырых пакетов scapy я пока это не реализовал (сложно), но на bash этот defence-приём выглядит нагляднее.
Соединяя этот prevent (https://github.com/s0i37/defence/blob/main/wifi/prevent/gtc.sh) с detect (https://github.com/s0i37/defence/blob/main/wifi/eap.py) получаем средство автоматического реагирования на атаку с помощью Eaphammer (скрин).

[Media: Фото]</description><pubDate>Fri, 07 Nov 2025 08:34:16 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_260</guid></item><item><title>В этом примере, вместо отправки в радиоэфир хэшей от брутабельных паролей, мы отправили хакеру</title><link>https://t.me/s0i37_channel/259</link><description>В этом примере, вместо отправки в радиоэфир хэшей от брутабельных паролей, мы отправили хакеру
несколько десятков неподбираемых PMKID.
Что же, пожелаем хакеру удачи в этом бесперспективном деле!

[Media: Фото]</description><pubDate>Sat, 01 Nov 2025 07:23:28 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_259</guid></item><item><title>Реакция хакерского софта будет предсказуема. Bettercap, hcxdumptool, airodump-ng все начинают фиксировать фейковые PMKID хэши, идущие от атакуемой точки доступа и ни как не отличимые от настоящих...</title><link>https://t.me/s0i37_channel/258</link><description>Реакция хакерского софта будет предсказуема. Bettercap, hcxdumptool, airodump-ng все начинают фиксировать фейковые PMKID хэши, идущие от атакуемой точки доступа и ни как не отличимые от настоящих (скрин).
Достигнув такого успеха и насобирав столько хэшей да ещё и с каждой точки доступа хакер поспешит покинуть "место преступления" и приступить к брутфорсу PMKID...

[Media: Фото]</description><pubDate>Sat, 01 Nov 2025 07:23:20 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_258</guid></item><item><title>Считается, что сбор PMKID с беспроводных сетей WPA PSK это бесшумная атака. Однако ранее я показывал (https://t.me/s0i37_channel/191), что эта атака все же может быть замечена по особенностям...</title><link>https://t.me/s0i37_channel/257</link><description>Считается, что сбор PMKID с беспроводных сетей WPA PSK это бесшумная атака. Однако ранее я показывал (https://t.me/s0i37_channel/191), что эта атака все же может быть замечена по особенностям трафика. Более того можно не только детектить сбор PMKID, но и мешать её проведению. Для этого в момент обнаружения атаки мы можем отправлять фейковые PMKID-хэши в радиоэфир. И для реакции хакерского софта в радиоэфир нужно отправить пакеты beacon и EAPOL M1. А сгенерировать PMKID в M1 от произвольного пароля можно так:
import hmac,hashlib
import random,string
def get_password_unbrutable(len):
return "".join(map(lambda _:random.choice(string.printable[:95]),
range(len)))
def calculate_pmkid(password, ap, essid, sta):
pmk = hashlib.pbkdf2_hmac("sha1", password.encode("utf-8"),
essid.encode(), 4096, 32)
pmkid = hmac.new(pmk, b"PMK Name" + b(ap) + b(sta), hashlib.
sha1).digest()[:16]
return pmkid
password = get_password_unbrutable(8)
eapol_m1_data[95:117] = b"\xdd\x14\x00\x0f\xac\x04" + calculate_
pmkid(password, ap, essid, sta)
Полный код доступен в (https://github.com/s0i37/defence/blob/main/wifi/prevent/m1.py). Теперь соединяя это с детектом (https://github.com/s0i37/defence/blob/main/wifi/pmkid.py) получаем средство автоматического реагироаания на атаку (скриншот).

[Media: Фото]</description><pubDate>Sat, 01 Nov 2025 07:23:09 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_257</guid></item><item><title>Но если же хакер извлечёт все захваченные handshake, то он сбрутит все теже самые пароли что мы отправляли в радиоэфир (скрин).</title><link>https://t.me/s0i37_channel/256</link><description>Но если же хакер извлечёт все захваченные handshake, то он сбрутит все теже самые пароли что мы отправляли в радиоэфир (скрин).
Нам ни чего не мешает отправить сотни, тысячи таких handshake. Каждый из подобранных паролей это трата времени хакера на проверку актуальности.
Отправка заведомо брутабельного handshake лишь одна из тактик. Которая может найти применение если защищаемая wifi сеть имеет слабый пароль. Так мы хотя-бы имеем шанс затерять реальный подобранный handshake среди сотен фейковых.
Другой же тактикой может быть отправка не брутабельных handshake. Ведь каждый такой хэш поставленный на брутфорс снижает общую производительность, снижая тем самым и шансы на успешность взлома легитимного handshake.
Наконец отправка любого (брутабельного или нет) фейкового handshake в туже секунду что и отправка deauth пакетов не даст хакеру понимания был ли захвачен легитимный handshake или нет.

[Media: Фото]</description><pubDate>Fri, 17 Oct 2025 09:34:21 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_256</guid></item><item><title>Вполне закономерно, что хакер начнёт захватывать огромное количество handshake. На скрине можно видеть что bettercap захватывает их от того самого клиента которого он деаутентицировал. С виду и не...</title><link>https://t.me/s0i37_channel/255</link><description>Вполне закономерно, что хакер начнёт захватывать огромное количество handshake. На скрине можно видеть что bettercap захватывает их от того самого клиента которого он деаутентицировал. С виду и не скажешь что это фейковые handshake. Аналогичное поведение будет и у других инструментов: hcxdumptool, airodump-ng.
Дальше начинается самое интересное. Подготовку к брутфорсу хакер может проводить разными способами. Так если хакер выберет aicrack-ng, то увидит последний принятый handshake, а если hcxpcapngtool, то по дефолту он извлекает первый. Следовательно в каждом случае мы можем просто перезаписать легитимный handshake, защитив тем самым точку доступа и послать хакера брутить левый хэш.

[Media: Фото]</description><pubDate>Fri, 17 Oct 2025 09:34:08 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_255</guid></item><item><title>Сегодня существует большое слепое пятно безопасности - беспроводные сети. Ещё один периметр, который есть почти у каждой компании и который практически никогда ни чем не охраняется. В итоге все мы...</title><link>https://t.me/s0i37_channel/254</link><description>Сегодня существует большое слепое пятно безопасности - беспроводные сети. Ещё один периметр, который есть почти у каждой компании и который практически никогда ни чем не охраняется. В итоге все мы привыкли к тому что все атаки на этом поле невидимы и хакеру все сходит с рук.
В своих постах, а так же в статье (https://xakep.ru/2025/01/10/wireless-self-defence/) я показал, что это может быть не так, и продемонстрировал как детектить все актуальные атаки на wifi.
Но сейчас я хотел бы поделиться тем, как можно активно мешать хакеру.
И это будет маленький цикл постов про предотвращение/смягчение атак на wifi.
Что бы помешать хакеру провести захват WPA handshake через деаутентификацию, в момент детекта атаки мы можем начать отправлять в радиоэфир фейковые хэши. И что бы хакерский софт среагировал, достаточно отправить пакеты: beacon, EAPOL m1 и m2. А собрать произвольный handshake мы можем примерно так:
import hmac,hashlib
import random
def PRF_512(key,A,B):
return b''.join(hmac.new(key,A+chr(0).encode()+B+chr(i).encode(),hashlib.sha1).digest() for i in range(4))[:64]
def get_rand(n):
o = b''
for _ in range(n):
o += int(random.random()*255).to_bytes(1, 'big')
return o
pmk = hashlib.pbkdf2_hmac('sha1', password.encode(), essid.encode(), 4096, 32)
snonce = get_rand(32)
ptk = PRF_512(pmk, b"Pairwise key expansion", min(b(ap),b(sta))+max(b(ap),b(sta))+min(anonce,snonce)+max(anonce,snonce))
kck = ptk[0:16]
mic = hmac.new(kck, b"\x01\x03\x00\x75" + bytes(eapol_data_4[:77]) + bytes.fromhex("00000000000000000000000000000000") + bytes(eapol_data_4[93:]), hashlib.sha1).digest()[0:16]
eapol_data_4[77:77+16] = mic
Добавив вызов этого prevent-скрипта (https://github.com/s0i37/defence/blob/main/wifi/prevent/m2.py) в detect-скрипт (https://github.com/s0i37/defence/blob/main/wifi/deauth.py) мы получаем готовое решение для автоматического реагирования на атаку деаутентификации (скрин).

[Media: Фото]</description><pubDate>Fri, 17 Oct 2025 09:33:55 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_254</guid></item><item><title>Когда хакер атакует какой либо сервис, например брутит пароли, то обычно на такое реагируют блокированием его IP:</title><link>https://t.me/s0i37_channel/253</link><description>Когда хакер атакует какой либо сервис, например брутит пароли, то обычно на такое реагируют блокированием его IP:
iptables -A INPUT -s $attacker -j DROP
Но целеустремленного хакера этим врядли остановишь. Так почему бы не дать ему того что он хочет - пусть атакует, только немного не того кого ожидает...
Всего двумя правилами на фаерволе мы можем повернуть вредоносный трафик вспять и направить атаку на сам источник:
iptables -t nat -I PREROUTING -s $hacker -p tcp --dport 22 -j DNAT --to-destination $hacker:22
sysctl -w net.ipv4.ip_forward=1
iptables -t nat -I POSTROUTING -p tcp --dport 22 -d $hacker -j MASQUERADE
В отличие от блокировки порта такой трюк практически незаметен для хакера, ведь целевой порт как был открыт так и остался (изменится только баннер и удвоится IP.ttl). Но после ввода этих команд хакер будет подбирать пароли уже сам у себя (скрин), думая что атакует ваш сервер. И в случае если подберёт пароль установит себе криптомайнер, или что там они устанавливают.

[Media: Фото]</description><pubDate>Fri, 10 Oct 2025 09:38:40 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_253</guid></item><item><title>Не редки случаи, когда хакеры натравливают на свои цели тяжёлую артиллерию – коммерческие (обычно крякнутые) сканеры, такие как, например, Acunetix.</title><link>https://t.me/s0i37_channel/252</link><description>Не редки случаи, когда хакеры натравливают на свои цели тяжёлую артиллерию – коммерческие (обычно крякнутые) сканеры, такие как, например, Acunetix.
Всего через минуту, как хакер натравил на нас сканер уязвимостей, вся его оперативная память оказалась исчерпана, и вся ОС зависла на несколько минут. Разумеется, никаких результатов у такого сканирования не будет.
Велика вероятность, что если хакер попадёт в наш «ZIP-капкан», он ощутит и более негативные последствия…
В ОС Linux существует известная проблема механизма OOM Killer, при которой утечка памяти приводит к сильному замедлению системы вплоть до зависания ОС. И подвержены ей главным образом браузеры.
Так что, если хакер попробует открыть наш сайт в браузере, то его ОС после утечки всей памяти и вовсе намертво зависнет, до полной перезагрузки системы.
Повесив систему хакеру и, вероятно, вынудив его сделать жесткую перезагрузку, мы можем заставить его потерять какие-то несохранённые файлы.
Как же можно применить это для защиты функционирующего сайта? Одним из простых решений может быть проксирование на ZIP-бомбу через nginx какой-нибудь не используемый каталог сайта, но такой, который точно будут искать хакеры. Отличными выбором могут быть каталоги .git или .svn. Они вряд ли нужны вашему веб-приложению, но для любого хакера must-have заглянуть туда.
server {
...
location /.git {
proxy_pass http://localhost:8080;
}
}
Легитимные пользователи такие каталоги вряд ли станут искать, а тот, кто станет – будет проучен!

[Media: Фото]</description><pubDate>Mon, 06 Oct 2025 08:20:21 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_252</guid></item><item><title>Давайте теперь посмотрим, как справятся с нами разнообразные хакерские разведывательные сканеры, ведь именно они наша главная цель.</title><link>https://t.me/s0i37_channel/251</link><description>Давайте теперь посмотрим, как справятся с нами разнообразные хакерские разведывательные сканеры, ведь именно они наша главная цель.
Как правило, обнаружив сайт, хакеры запускают инструменты, простукивающие его рабочий каталог на наличие потенциально интересных ресурсов. Например, хакер может сделать это популярным инструментом dirsearch.
Обычно такие инструменты закидывают сайт десятками тысяч запросов, но тут на первом же запросе ещё на этапе калибровки dirsearch исчерпал всю память и аварийно завершился. И произошло это через каких-то 3-4 секунды.
Другие аналоги: wfuzz, ffuf ведут себя аналогичным образом - падают наступив на ZIP-мину.
Падение даже одного хакерского процесса с полным исчерпанием ресурсов ОС негативно сказывается и на общей производительности системы - тк память всех соседних процессов вытесняется на диск (swap), а сам дисковый кэш, обеспечивающий быстрый ввод-вывод, будет сброшен.

[Media: Фото]</description><pubDate>Mon, 06 Oct 2025 08:20:12 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_251</guid></item><item><title>Сегодня веб формирует большую часть поверхности атак современного периметра.  И есть один весьма болезненный приём против хакеров, ковыряющих чужой веб...</title><link>https://t.me/s0i37_channel/250</link><description>Сегодня веб формирует большую часть поверхности атак современного периметра.  И есть один весьма болезненный приём против хакеров, ковыряющих чужой веб...
Протокол HTTP для экономии трафика позволяет доставлять содержимое со сжатием. Но насколько сильного сжатия можно достичь, если использовать лишь одну единственную последовательность – например, всего один байт?
Традиционно ZIP-бомбы являлись оружием хакеров, но
PatientZero предложил интересную идею их использования в агрессивно защитных целях - ZIP-мины.
Так всего один 1МБ данных, принятых по протоколу HTTP, может развернуться у хакера в 1ГБ в его оперативной памяти. 10МБ, соответственно, превратится уже в 10ГБ, что почти наверняка положит процесс на типовом арендованном сервере. Ну а 30МБ думаю хватит с головой и на средний десктоп.
Сегодня открытие обычного сайта в браузере – это скачивания порядка 10МБ данных, что с нынешними скоростями происходит за пару секунд. Значит 10ГБ оперативной памяти мы заберем у атакующего быстрее, чем он успеет подумать.
Такая встречная атака настолько проста в реализации, что провернуть её можно даже в терминале всего несколькими командами (скрин). Теперь открытие любой веб-страницы на таком листенере вызовет взрыв ZIP-бомбы в RAM, которая заберёт всю память в радиусе 10ГБ.

[Media: Фото]</description><pubDate>Mon, 06 Oct 2025 08:20:01 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_250</guid></item><item><title>Другим вариантом испортить сканирование является его экстремальнное замедление. Мы можем отправлять по одному байту раз в секунду и делать так бесконечно. И вот сколько часов уходит на анализ только...</title><link>https://t.me/s0i37_channel/249</link><description>Другим вариантом испортить сканирование является его экстремальнное замедление. Мы можем отправлять по одному байту раз в секунду и делать так бесконечно. И вот сколько часов уходит на анализ только одного открытого порта (скрин).
Скрипт https://github.com/s0i37/defence/blob/main/garbage.py из моей defence-коллекции умеет делать и то и другое.

[Media: Фото]</description><pubDate>Mon, 29 Sep 2025 09:20:48 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_249</guid></item><item><title>Как ещё мы можем навставлять палки в колеса хакерам, сканирующим наши ресурсы?</title><link>https://t.me/s0i37_channel/248</link><description>Как ещё мы можем навставлять палки в колеса хакерам, сканирующим наши ресурсы?
Можно начать отправлять бесконечный трафик с каждого всевдо-открытого порта, например nc -nv -lp 8888 &lt; /dev/urandom.
И вот как реагирует на это nmap атакующего (скрин). Несколько гигов оперативки на один порт.
Однако nmap не одинаково реагирует на разные байты, так было установлено что байты 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x08, 0x0a, 0x0b, 0x0e, 0x0f, 0x10, 0x11 вызывают более сильное исчерпание ресурсов. Вплоть до полного потребления RAM и SWAP и аварийного завершения (скрин).
Если мы имеем дело не с хакером, а с ботами, то их автоматизированный конвейер вполне может рухнуть от банальной утечки памяти.
Правда такое потребует от нас лить немало трафика, что иногда является расточительством.

[Media: Фото]</description><pubDate>Mon, 29 Sep 2025 09:20:40 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_248</guid></item><item><title>Возможно кто то из вас скажет "так есть же portspoof". Действительно, но есть у него один маленький изъян - он уж слишком рандомный и каждый раз на одном и том же порту иммитирует новый сервис, что...</title><link>https://t.me/s0i37_channel/247</link><description>Возможно кто то из вас скажет "так есть же portspoof". Действительно, но есть у него один маленький изъян - он уж слишком рандомный и каждый раз на одном и том же порту иммитирует новый сервис, что уже не правдоподобно и может быть вычислено.
И вот как кстати можно обойти portspoof: достаточно два раза сделать nmap -sV, где баннеры не совпали там подделка, где совпали - истинный сервис.
Разумеется такой недочёт исправлен в моем скрипте.

[Media: Фото]</description><pubDate>Fri, 26 Sep 2025 09:31:45 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_247</guid></item><item><title>Надоело что ваш периметр постоянно сканируют nmap? Как на счет сделать все порты открытыми? Сделать это можно буквально в пару команд:</title><link>https://t.me/s0i37_channel/246</link><description>Надоело что ваш периметр постоянно сканируют nmap? Как на счет сделать все порты открытыми? Сделать это можно буквально в пару команд:
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 22 -j REDIRECT --to-ports 22
iptables -t nat -A PREROUTING -i eth0 -p tcp -m conntrack --ctstate NEW -j REDIRECT --to-ports 1234
while sleep 1; do nc -nv -lp 1234; done
А коммерческие фаерволы умеют это из коробки.
Но я предлагаю пойти дальше - иммитировать случайный сервис на каждом псевдо-открытом порту. Мой ещё один скрипт из defence-коллекции (https://github.com/s0i37/defence/blob/main/services.py) прекрасно справляется с этим. Он использует туже самую базу фингерпринтов nmap для иммитации сервиса (nmap-service-probes), но на этот раз использует ответы.
И как теперь среди этого найти настоящие сервисы?

[Media: Фото]</description><pubDate>Fri, 26 Sep 2025 09:31:34 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_246</guid></item><item><title>Почему когда мы сканируем порты то часто получаем результат в ту же секунду, а иногда ждём десятки минут? Всё дело в TCP-RST пакетах...</title><link>https://t.me/s0i37_channel/245</link><description>Почему когда мы сканируем порты то часто получаем результат в ту же секунду, а иногда ждём десятки минут? Всё дело в TCP-RST пакетах...
Самый простой способ помешать хакеру проводить сканирование портов реализуется буквально в одну простую команду:
iptables -A OUTPUT -o eth0 -p tcp --tcp-flags RST RST -j DROP
Всего одно правило на фаерволе в десятки тысяч раз замедляет сканирование портов вашего сервера.
Это правило запрещает вашей системе отправлять RST-пакет на каждый закрытый порт если его сканируют. Что в свою очередь вынуждает атакующего каждый раз выжидать определенное время для принятия решения о статусе порта.
И это будет маленький цикл статей про грабли и приколы против хакеров.

[Media: Фото]</description><pubDate>Mon, 22 Sep 2025 10:01:37 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_245</guid></item><item><title>3. Понять что те или иные разные IP-адреса это фактически один и тот же компьютер.</title><link>https://t.me/s0i37_channel/244</link><description>3. Понять что те или иные разные IP-адреса это фактически один и тот же компьютер.
Наконец, помониторив трафик более продолжительное время мы можем заметить, что uptime одной из машин за VPN-сервером внезапно совпал с одной из машин, чей трафик пришёл из провайдерской домашней сети (скрин).
Только что мы сделали деанон атакующего, который по неосторожности допустил утечку сетевых пакетов вне VPN. Несмотря на то, что ни какие видимые компрометирующие данные хакер явно не посылал, всего одного пакета хватило, чтобы сопоставить его VPN-активность с домашним IP.
И это хороший пример почему proxy более анонимен нежели vpn. Хоть vpn и удобнее для хакера, но он не делает развязки по сетевому стеку, позволяя проводить такой fingerprint.

[Media: Фото]</description><pubDate>Fri, 19 Sep 2025 12:43:20 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_244</guid></item><item><title>2. Увидеть сколько фактических источников трафика находится за IP-адресом.</title><link>https://t.me/s0i37_channel/243</link><description>2. Увидеть сколько фактических источников трафика находится за IP-адресом.
Помониторив какое то время за трафиком с данного узла можно заметить что пакеты приходят с трёмя разными uptime (скрин).
Иными словами этим VPN пользуется минимум три машины и возможно три человека.

[Media: Фото]</description><pubDate>Fri, 19 Sep 2025 12:43:12 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_243</guid></item><item><title>В протоколе TCP, скрыто одно очень интересное поле — опция timestamp, по которой можно рассчитать время когда была загружена ОС. И что ещё интереснее, эту опцию ОС зачастую указывает сама, даже если...</title><link>https://t.me/s0i37_channel/242</link><description>В протоколе TCP, скрыто одно очень интересное поле — опция timestamp, по которой можно рассчитать время когда была загружена ОС. И что ещё интереснее, эту опцию ОС зачастую указывает сама, даже если её об этом явно не просят. Такая информация встречается не только при исходящих подключениях, но и так же входящих. То есть большинство из тех узлов что посылают на нас трафик и как-то пытаются атаковать, бессознательно разглашают в TCP-пакетах свои uptime.
Не на всех типах ОС это поле фактически совпадает с временем загрузки, но важно другое — оно постоянно и достаточно уникально для каждого компьютера. А значит оно, подобно уникальному хэшу, способно выделить трафик произвольного ПК из общей массы, вне зависимости от его IP! Для этого я написал скрипт (https://github.com/s0i37/defence/blob/main/uptime.py)
И с этой информацией мы можем:
1. Различать IP-адрес и фактический источник атаки. То есть является ли этот узел реально вредоносным или это лишь шлюз. Для этого нужно сравнить uptime у входящего подключения с uptime который мы запросим у соответствующего IP. В примере на скрине uptime у входящего подключения не совпал с фактическим uptime у узла. Это означает, что данный узел не является фактическим источником атаки, он только шлюз и пересылает через себя чьи-то пакеты. Имя сети указывает на то, что это обычный хостинг. Учитывая что фингерпринты различаются, хакер использует этот сервер в качестве VPN, а не прокси — т. к. сервер пересылает чужие пакеты целиком.
Такое ещё можно сделать анализом IP.ttl о чём я писал ранее.

[Media: Фото]</description><pubDate>Fri, 19 Sep 2025 12:42:59 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_242</guid></item><item><title>Ещё одна любопытная вещь, которую мы можем узнать об атакующем по его трафику, реализуется через анализ IP.id. Я уже писал ранее об этом поле в пакете (https://t.me/s0i37_channel/43), что оно часто...</title><link>https://t.me/s0i37_channel/241</link><description>Ещё одна любопытная вещь, которую мы можем узнать об атакующем по его трафику, реализуется через анализ IP.id. Я уже писал ранее об этом поле в пакете (https://t.me/s0i37_channel/43), что оно часто является глобально инкрементируемым, а значит что анализируя его изменение мы можем видеть сколько пакетов источник трафика отправляет куда то ещё кроме нас. Иными словами мы можем заключить - является ли атака таргетированной или веерной на множество хостов.
Еще один скрипт из моей defence-коллекции (https://github.com/s0i37/defence/blob/main/ip_id.py) автоматически делает это. По каждому входящему сетевому пакету мы можем видеть страну, город, имя сети, ОС, а так же количество пакетов генерируемых хостом куда то ещё кроме нас. Как можем видеть на примере первый источник трафика имеет слабый инкремент, свидетельствующий что практически ни куда кроме нашего узла он пакеты не посылает — это говорит о вероятно таргетированной атаке. Второй узел помимо нас успевает отправить от нескольких сотен до тысячи пакетов — это говорит о вероятной веерной атаке сразу на множество узлов.

[Media: Фото]</description><pubDate>Mon, 15 Sep 2025 07:37:22 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_241</guid></item><item><title>Пару лет назад я написал статью кунг-фу enumeration (https://xakep.ru/2022/11/17/enumeration-guide/) где поделился tcp/ip сетевыми трюками, что могут быть применены атакующим для получения разной...</title><link>https://t.me/s0i37_channel/240</link><description>Пару лет назад я написал статью кунг-фу enumeration (https://xakep.ru/2022/11/17/enumeration-guide/) где поделился tcp/ip сетевыми трюками, что могут быть применены атакующим для получения разной неочевидной информации о цели. Но как на счёт обратного? Узнать что то об атакующем, только по его трафику.
Это будет небольшая серия постов про "обратный" enumeration.
Я уже рассказывал, как много может дать нам анализ ip.ttl, но ещё по этому полю пакета мы можем понять где находится реальный источник трафика - на узле с белым ip как выделенный сервер, или где то в глубине локальной сети за NAT, то есть является обычной рабочей станцией. Все что нужно это посчитать разницу ip.ttl у входящего и исходящего подключений. У сервера с белым ip разница будет нулевая, а у узлов за NAT соответственно не нулевая.
Мой скрипт (https://github.com/s0i37/defence/blob/main/nat.py) делает всю эту магию. Для каждого источника входящего трафика он определяет город, страну, имя сети whois, тип ОС, а так же делая встречный ping, вычисляет где расположен хост на DMZ или в локалке, как глубоко, и сколько узлов нас разделяет.

[Media: Фото]</description><pubDate>Wed, 10 Sep 2025 11:05:40 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_240</guid></item><item><title>Заметил как то забавную вещь. В ходе пентеста получаю уведомление от скрипта из предыдущего поста, что таргет заблокировал меня, проверяю - действительно порт стал закрыт, но dirsearch на этот таргет...</title><link>https://t.me/s0i37_channel/239</link><description>Заметил как то забавную вещь. В ходе пентеста получаю уведомление от скрипта из предыдущего поста, что таргет заблокировал меня, проверяю - действительно порт стал закрыт, но dirsearch на этот таргет при этом продолжает работать. Как такое может быть?
Причина это Keep-alive, что использует соединение многократно. И как становится понятным фаерволы и waf могут ненадежно защищать цель, блокируя новые подключения, но забывая про уже установленные коннекты (скрин).
И вот как можно попробовать сделать bypass таких waf:
socat -v tcp-listen:1234,fork,reuseaddr - &lt; /tmp/fifo | socat -v - tcp-connect:1.2.3.4:80,keepalive,keepidle=10,keepintvl=10,keepcnt=100 &gt; /tmp/fifo
socat -v tcp-listen:1234,fork,reuseaddr - &lt; /tmp/fifo | socat -v - openssl:1.2.3.4:443,verify=0 &gt; /tmp/fifo
dirsearch -u http://127.0.0.1:1234
Что бы многократно использовать одно и то же tcp-соединение и разделять его между разными утилитами (dirsearch, gobuster, etc) мы можем создать до блокировки висящее подключение.
Конечно же такой коннект рано или поздно может закрыть и удаленная сторона, но сам факт того, что мы взаимодействуем с target после активации waf весьма интересен.

[Media: Фото]</description><pubDate>Fri, 15 Aug 2025 08:20:27 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_239</guid></item><item><title>Написал чрезвычайно простой но эффективный скрипт для мониторинга доступности целей во время пентеста.</title><link>https://t.me/s0i37_channel/238</link><description>Написал чрезвычайно простой но эффективный скрипт для мониторинга доступности целей во время пентеста.
#!/bin/bash
sites="$1" # ip port schema vhost
[ -z "$AGENT" ] &amp;&amp; AGENT='Mozilla/5.0'
DOWNLOAD_TIME=10
INTERVAL=5
shopt -s lastpipe
while sleep $INTERVAL; do
date
cat "$sites" | while read ip port schema vhost; do
code=$(curl -s --insecure --http1.1 --max-time $DOWNLOAD_TIME -A "$AGENT" -X 'GET' --connect-to "$vhost::$ip" -H "Host: $vhost" "$schema://$vhost:$port/" -w '%{http_code}' -o /dev/null 2&gt; /dev/null)
words=$(curl -s --insecure --http1.1 --max-time $DOWNLOAD_TIME -A "$AGENT" -X 'GET' --connect-to "$vhost::$ip" "$schema://$vhost:$port/" 2&gt; /dev/null | wc -w)
if ! grep -q "$ip $port $vhost:" /tmp/http_mon.log 2&gt; /dev/null; then # init
echo "[*] $ip $port $vhost: $code $words"
echo "$ip $port $vhost: $code $words" &gt;&gt; /tmp/http_mon.log
elif ! grep -q "$ip $port $vhost: $code $words" /tmp/http_mon.log; then # ban
echo "[-] $(grep "$ip $port $vhost:" /tmp/http_mon.log)"
echo "[+] $ip $port $vhost: $code $words"
mplayer siren.mp3
pkill --signal STOP -f "$ip|$vhost"
else # ok
pkill --signal CONT -f "$ip|$vhost"
fi
done
done
В чем суть. Когда мы делаем активную разведку (gobuster vhost, dirsearch, arjun), что является весьма инвазивной активностью, часть таргетов может отлетать из за waf или firewall. И если мы применяем автоматизацию в виде всем известных пайплайнов, то приличная часть запросов не достигнет целей, а мы возможно даже не заметим этого. Но только не теперь.
Скрипт постоянно мониторит таргеты и даёт понять, что какая то цель заблокировала нас - когда меняется fingerprint сайта (код+длина). Так же скрипт умеет сам ставить на паузу все запущенные процессы, что атакуют данный таргет и возобновляет их если блокировка снята.</description><pubDate>Tue, 12 Aug 2025 10:51:58 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_238</guid></item><item><title>Миновал 3й ежегодный Pentest Awards, на котором мне довелось занять 2е место в номинации out of scope с работой "Google в локалке".</title><link>https://t.me/s0i37_channel/237</link><description>Миновал 3й ежегодный Pentest Awards, на котором мне довелось занять 2е место в номинации out of scope с работой "Google в локалке".
Спасибо жюри, что оценили работу!
Так же поздравляю моих коллег из УЦСБ, с победой @VlaDriev, @Oki4_Doki (канал @GigaHack), @Levatein (1C hacker) , @N4m3U53r, @Alevuc (автор последней обложки xaker.ru) в этой и других номинациях. Практически каждый из наших пентестеров занял призовое место!
Пару слов о моём кейсе. В этом году решил не подаваться во взломы, а попробовать в разработке.
Моя номинированная разработка (Google за 200 строк кода на bash) фактически была реализована еще 9 лет назад, но так вышло, что только недавно я решил о ней написать достаточно подробно и заслать в подходящую номинацию. Тогда в 2016, я и подумать не мог что это принесёт мне победу в таком далёком будущем. Все потому что проблема чувствительных данных актуальна будет всегда.
В последующие годы между (и в ходе) пентестов я сделал ещё множество разработок от небольших утилит до целых систем. Что то из этого я не смогу опубликовать в ближайшее время т.к. это либо для внутреннего использования либо для личных исследований. Но частью своих разработок я еще ни раз поделюсь!

[Media: Фото]</description><pubDate>Mon, 04 Aug 2025 09:40:30 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_237</guid></item><item><title>Обычно не делаю рекламы в своём канале, но для жены сделал исключение (ИБ у нас семейное ремесло). Знаю, что меня читают не только пентестеры, но и другие специалисты ИБ.</title><link>https://t.me/s0i37_channel/236</link><description>Обычно не делаю рекламы в своём канале, но для жены сделал исключение (ИБ у нас семейное ремесло). Знаю, что меня читают не только пентестеры, но и другие специалисты ИБ.
Хочу порекомендовать канал своей жены, которая занимается Комплаенсом более 10 лет. Экспертный канал о требованиях ИБ в области персональных данных и критической информационной инфраструктуры
https://t.me/itiscompliance</description><pubDate>Fri, 01 Aug 2025 07:33:43 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_236</guid></item><item><title>Маленькие хакерские секреты простых вещей. Как на пентесте быстро и просто увидеть что цель это ханипот. И при этом даже не спускаясь с сетевого уровня до уровня приложения.</title><link>https://t.me/s0i37_channel/235</link><description>Маленькие хакерские секреты простых вещей. Как на пентесте быстро и просто увидеть что цель это ханипот. И при этом даже не спускаясь с сетевого уровня до уровня приложения.
Все дело в том что, многие производители ханипотов часто забывают эмулировать стэк ОС для соответствующих специфичных сервисов.
Видим типичный набор портов Windows, а сетевой стэк Linux.

[Media: Фото]</description><pubDate>Thu, 31 Jul 2025 09:00:45 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_235</guid></item><item><title>Wi-Fi pivoting.</title><link>https://t.me/s0i37_channel/234</link><description>Wi-Fi pivoting.
Когда физический периметр пробит через WiFi нужно развивать атаки в локалке. Физическое расположение может накладывать на нас ограничения по возможностям и удобству, не позволяя проводить работы в том или ином месте. И тут мы можем использовать одноплатник с 4g модемом, оставленный в точке приёма или Android смартфон в кармане у коллеги, что будет стоять в нужной точке. Оба варианта после подключения к целевой беспроводной сети настраиваются в режим 4g-&gt;wifi шлюза (ip_forward + masquerade), давая комфортный удаленный доступ в сеть с любого места через данные устройства. С этим всё достаточно просто и этот приём я хорошо описывал в статье на ][ и в своей книге.
Если все машины в целевой wifi сети пропатчены или закрыты фаерволом в ход можно пустить MiTM атаки (перехват трафика) и responder. Но что бы проводить такие атаки нужно быть непосредственно подключенным к wifi либо организовать L2-туннель в целевую сеть.
Как правило такое достигается через сетевой мост. Но к сожалению в Linux сбриджить wlan0 и vpn можно только в режиме точки доступа (AP), тогда как мы находимся в режиме клиента (STA), будучи подключенными к целевой сети.
Встроенная в Linux утилита tc, способная зеркалировать интерфейсы, так же не справляется с этой задачей (по крайней мере мне не удалось).
И тут я вспомнил про одну древнюю и простую программку https://github.com/escitalopram/wlan_kabel, которая способна сделать как раз то что нам нужно.
sudo ssh root@android_or_rpi -o Tunnel=ethernet -w any:any
wpa_supplicant -i wlan0 -c /tmp/target.conf
./wlan_kabel "wlan0" "tap1" "$mac_of_your_tap"
После ввода этой команды (на удаленном одноплатнике или android) на локальном ноутбуке tap-интерфейс от ssh будет L2-связан с целевым Wi-Fi, открывая удаленное проведение MiTM и responder-атак.</description><pubDate>Tue, 29 Jul 2025 09:01:26 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_234</guid></item><item><title>Сейчас мой краулер (https://github.com/s0i37/crawl) парсит следующие форматы: word, excel, презентации, visio, pdf - из всех этих типов умеет извлекать вложенные картинки, так же парсит все типы...</title><link>https://t.me/s0i37_channel/233</link><description>Сейчас мой краулер (https://github.com/s0i37/crawl) парсит следующие форматы: word, excel, презентации, visio, pdf - из всех этих типов умеет извлекать вложенные картинки, так же парсит все типы архивов с бесконечной вложенностью, cab/rpm/deb-пакеты, все исполняемые файлы (pe,elf), распознает текст на картинках (ru,en), в аудио (ru,en), с fps=1 распознает что есть в видео включая звук, извлекает thumbs.db, sqlite, дампы трафика, lnk-файлы, декомпилирует байткод, и логи винды evtx - одним словом всё, чаще всего лежит на шарах. И делает это все за какие то 300 строк кода на bash.
А теперь благодаря специально собранному мини образу alpine, с ntfs-3g и impacket, запускаему через qemu, краулер из любого образа диска быстро и без скачивания извлечет /root/.bash_history, /home/*/.bash_history, /etc/shadow, историю браузера, а так же хэши sam и security.

[Media: Видео]</description><pubDate>Fri, 27 Jun 2025 11:54:44 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_233</guid></item><item><title>Но что если мы имеем дело с vhdx, vdi, vmdk образами? И на помощь тут может прийти qemu. Qemu умеет открывать все популярные форматы образов дисков на лету, без предварительной переконвертации. И вот...</title><link>https://t.me/s0i37_channel/232</link><description>Но что если мы имеем дело с vhdx, vdi, vmdk образами? И на помощь тут может прийти qemu. Qemu умеет открывать все популярные форматы образов дисков на лету, без предварительной переконвертации. И вот такой командой мы можем запустить виртуалку задействовав нужный образ диска прямо с шары:
sudo kvm -hda kali.qcow2 -drive file=/media/share/path/to/server.vhdx,format=vhdx -snapshot
После чего внутри виртуалки мы уже можем подмонтировать диск и приступить к поиску информации в нём, не скачивая при этом сотни гигабайт.
Как можно заметить на скриншоте для открытия образа в 120ГБ потребовалось скачать лишь 5МБ.
Получается какой бы большой файл мы не нашли на SMB, всё может быть доступно без полного скачивания, нужно лишь знать подход.

[Media: Фото]</description><pubDate>Fri, 27 Jun 2025 11:54:30 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_232</guid></item><item><title>В любой локальной сети общедоступные сетевые диски большая проблема для безопасности и об этом я писал статью (https://www.google.com/amp/s/habr.com/ru/amp/publications/878340/) . Но поиск иголки в...</title><link>https://t.me/s0i37_channel/231</link><description>В любой локальной сети общедоступные сетевые диски большая проблема для безопасности и об этом я писал статью (https://www.google.com/amp/s/habr.com/ru/amp/publications/878340/) . Но поиск иголки в стоге сена (файликов с паролями) лишь один из подходов. Как на счёт поиска чего то грандиозного - например бэкапов?
Найти бэкапы даже где то в глубине сотен сетевых дисков не так уж и сложно - их выдаёт размер. Для этого нам нужно рекурсивно собрать списки файлов, включая их размер. Элегантно сделать это можно маленьким циклом:
while read ip share; do mount.cifs "//$ip/$share" /mnt/1 -o ro,user=user,pass=pass
timeout 300 find "/mnt/1" -printf '%p | %k KB | %t\n'
sudo umount /mnt/1
done &gt; smb-files.txt
Утилита find умеет среди прочего фиксировать размер и дату файла.
Дальше что бы найти файлы, скажем за 2025 год и более 1ГБ можно воспользоваться командой:
cat smb-files.txt | grep ' 2025' | egrep ' [0-9]{6,10} KB'
И перед нами появляются бэкапы 1ГБ, 10ГБ, 100ГБ.
И теперь возникает главный вопрос - что делать если перед нами лежит огромный файл, а сеть или время не позволяет его полностью скачать? Ответ перед нашими глазами - SMB. SMB предоставляет нам сетевой ввод-вывод, так что мы можем просто смонтировать нужный сетевой диск и открыть файл будто бы он локальный. Это позволит читать файл не целиком, а лишь нужные его части. Например из любого архива мы всегда можем достать только нужный нам файл, а листинг займёт лишь пару мегабайт:
mount.cifs "//fs.corp/backup" /media/share -o ro,user=user,pass=pass
7z x /media/share/path/to/dc.7z windows/system32/ntds.dit
В результате мы можем обработать файл не скачивая его.</description><pubDate>Fri, 27 Jun 2025 11:54:18 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_231</guid></item><item><title>Пару дней назад сделал коммит в radare2 и теперь вот так он может выглядеть сразу из коробки. Инфраструктура для реверс-инжиниринга Radare2 достаточно сложна для новичка, тк сильно завязана на...</title><link>https://t.me/s0i37_channel/230</link><description>Пару дней назад сделал коммит в radare2 и теперь вот так он может выглядеть сразу из коробки. Инфраструктура для реверс-инжиниринга Radare2 достаточно сложна для новичка, тк сильно завязана на хоткеях и не имеет большого встроенного визуала. Теперь с новыми дефолтными панелями можно комфортно дебажить x86 и x86_64 с декомпиляцией и подсветкой кода, просматривать регистры, переменные, стэк и видеть какие байты читаются/пишутся в памяти. Максимально стилизированно под ollydbg, стандарт в дебагинге.
И раз radare2 это в первую очередь SBA, то такой подход можно применять не только в динамике (отладке), но и в статическом анализе, благодаря встроенному эмулятору ESIL.

[Media: Фото]</description><pubDate>Fri, 20 Jun 2025 08:39:23 +0000</pubDate><guid isPermaLink="false">telegram_s0i37_channel_230</guid></item></channel></rss>